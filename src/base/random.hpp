#pragma once
#include <algorithm>
#include <iterator>
#include <limits>
#include <cstdint>

namespace bgl{
/**
 * xoshiro256** is a fast, high-quality random number generator<br>
 * partially satisfies RandomNumberEngine requirements<br>
 * refer to: http://xoshiro.di.unimi.it/
 * @brief xoshiro256** random number generator
 */
class xoshiro256 {
public:
  using result_type = std::uint64_t;

  static constexpr result_type default_seed = 1u;

  static constexpr result_type min() {
    return std::numeric_limits<result_type>::min();
  }

  static constexpr result_type max() {
    return std::numeric_limits<result_type>::max();
  }

  /**
   * @brief generate random number
   * @return generated number
   */
  result_type operator()() {
    const result_type s = rotl(state_[1] * 5, 7) * 9;
    const result_type t = state_[1] << 17;
    state_[2] ^= state_[0];
    state_[3] ^= state_[1];
    state_[1] ^= state_[2];
    state_[0] ^= state_[3];
    state_[2] ^= t;
    state_[3] = rotl(state_[3], 45);
    return s;
  }

  explicit xoshiro256(result_type value = default_seed) {
    seed(value);
  }

  template <class Sseq>
  explicit xoshiro256(Sseq& q) {
    seed(q);
  }

  /**
   * @brief reinitialize the internal state using new seed value
   * @param value seed value
   */
  void seed(result_type value = default_seed) {
    for (int i = 0; i < 4; ++i) {
      state_[i] = splitmix64_next(value);
    }
  }

  /**
   * @brief reinitialize the internal state using new seed value
   * @param q seed sequence
   */
  template <class Sseq>
  void seed(Sseq& q) {
    q.generate(
      reinterpret_cast<uint32_t*>(std::begin(state_)),
      reinterpret_cast<uint32_t*>(std::end(state_))
    );
  }

  /**
   * @brief advance state as if by |z| consecutive calls of operator()
   * @param z the number of calls
   */
  void discard(unsigned long long z) {
    for (unsigned long long i = 0; i < z; ++i) {
      (*this)();
    }
  }

  bool operator==(const xoshiro256& rhs) const {
    return std::equal(
      std::begin(state_),
      std::end(state_),
      std::begin(rhs.state_)
    );
  }

  bool operator!=(const xoshiro256& rhs) const {
    return !(*this == rhs);
  }

private:
  result_type state_[4];

  // (modern compilers can optimize this into a single rotate instruction)
  static result_type rotl(result_type x, int k) {
    return (x << k) | (x >> (64 - k));
  }

  /**
   * @brief splitmix64 generator. used for seed initialization
   * @param x current value
   * @return next random value generated by splitmix64
   */
  static result_type splitmix64_next(result_type& x) {
    result_type z = (x += 0x9e3779b97f4a7c15);
    z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
    z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
    return z ^ (z >> 31);
  }
};

//! alias of xoshiro256
using rng_t = xoshiro256;

// global random number generator for lazy guys
extern rng_t bgl_random;
} // namespace bgl
